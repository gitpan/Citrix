=head1 NAME

DEPRECATED: Package for Citrix environment global configuration options (Now see: Citrix).

=head1 DESCRIPTION

Please do not use this.

=cut

# PROBLEM: Makes tests fail because of name "Config"
# TODO: Move to use StoredHash for storing farms, 

#Acts as a container for the Citrix farms configuration.
#Farm info will be accessed only in "big" applications dealing with multiple farms.

#If Citrix command line utilities were installed in a custom path, there
#is a class variable $binpath to set this path into.

# NOTE: DBI-based loading is not offcially supported yet,
# Thus not published and included in POD
# Farm Config
package Citrix::Config;
use Data::Dumper;
use Scalar::Util;

#our $VERSION = "0.024";


#our $farms;
#our $domain = '';
#our $admins = {}; 

# Table to store the Farm configurations in
our $farmtabname = 'citrixfarm';
# Database fields (mapp. from db to rt)
our @fnm = (
   ['farmid','id'], ['masterhost','mh'], ['domsuffix','ds'],
   ['farmname','n',], ['apps','a'], ['servhosts','h'], ['seqid','s'],
); # applist(1) hostlist(1)
# Reverse map ?





# Load Citrix Farms from DB.
# Field names are translated to internal runtime fieldnames.
sub load_db {
   my ($dbh, %opt) = @_;
   my $tn = $opt{'tabname'} || $farmtabname;
   # Map from DB names to rt
   
   my $w = " WHERE active = 1";
   my $sby = " ORDER BY seqid";
   my $qs = "SELECT ".join(',', map({"$_->[0] $_->[1]";} @fnm))." FROM $tn ";
   #my $sth = $dbh->prepare($qs) || die("Failed to prepare $qs");
   #$sth->execute() || die("Failed to execute");
   my $arr = $dbh->selectall_arrayref($qs, {Slice => {} });
   #$sth->finish();
   # Separate mapp for array fields to rt
   my %fidx = map({
      $_->{'h'} = [split(/,\s*/, $_->{'h'})];
      $_->{'a'} = [split(/,\s*/, $_->{'a'})];
      #DEBUG:print("Entyry:\n".Dumper($_));
      ($_->{'id'}, $_);
   } @$arr);
   #my %fidx = map({($_->{'id'}, $_);} @$arr);
   
   $farms = \%fidx;
   return(\%fidx);
}

# Internal / Legacy farm import routine stored here just in case it shows to be useful for someone.
# Takes farm config as hash-of-hashes (with ids in inner nodes) and 
sub farmimport {
   my ($fms, $dbh, %opt) = @_;
   my $ftabname = $opt{'tabname'} || $farmtabname;
   my @dbattr = ('farmid','farmname','masterhost','domsuffix','servhosts','apps','seqid',);
   my @rtattr = ('id','n','mh','ds','h','a','s',);
   my @aa = ('h','a');
   my @farms = map({my $fn = $fms->{$_};@$fn{@aa} = map({join(',',@{$fn->{$_}});} @aa);$fn;} sort({$fms->{$a}->{'s'} <=> $fms->{$b}->{'s'};} keys(%$fms)));
   my @farms2 = map({my %h;@h{@dbattr} = @$_{@rtattr};\%h;} @farms);
   #DEBUG:print("<pre>".Dumper(\@farms2)."</pre>");
   my $qi = "INSERT INTO $ftabname (".join(',', @dbattr).") VALUES (".join(',',map({'?';} @dbattr)).")";
   my $sth = $dbh->prepare($qi);
   map({
      my @vals = @$_{@dbattr};
      #DEBUG:print("SQL: $qi<br/>\n".Dumper(\@vals)."<br/>\n");
      my $ok = $sth->execute(@vals);
      
   } @farms2);
}


1;
